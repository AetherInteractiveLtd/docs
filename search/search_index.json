{"config":{"lang":["en"],"separator":"[\\s\\-]+"},"docs":[{"title":"Welcome to Aether's Developer Documentation","text":"","location":""},{"title":"Glossary","text":"","location":"#glossary"},{"title":"Tina","text":"<ul> <li>Creating a Project with Tina *</li> </ul>","location":"#tina"},{"title":"Welcome to the API Documentation for Tina","text":"<p>Please follow Getting Started to get started with Tina.</p>","location":"api/api_docs/"},{"title":"Process","text":"<p>A Process should operate as any core feature.</p>","location":"api/process/"},{"title":"Process","text":"","location":"api/process/#process"},{"title":"<code>&lt;empty&gt;</code>","text":"","location":"api/process/#empty"},{"title":"Event Parameters","text":"<code>dt: number</code>  <p><code>dt</code> is always equal to the delta between the last time a tick was processed and the current time. This value is presented in seconds.</p>  Warning <p>This will not respect the latest run of the current process, it will respect the latest run of the overall process scheduler.</p>","location":"api/process/#event-parameters"},{"title":"<code>when(): EventListener</code>","text":"","location":"api/process/#markdown"},{"title":"Returns","text":"<code>EventListener</code>   <p>A new <code>EventListener</code> for you to run actions during a <code>Process</code> tick.</p>","location":"api/process/#returns"},{"title":"<code>resume(): boolean</code>","text":"<p>This resumes your <code>Process</code> if it was paused, otherwise it does nothing.</p>","location":"api/process/#markdown"},{"title":"Returns","text":"<code>boolean</code>  <p>Whether or not resuming the process did anything. This basically returns <code>true</code> if the process did not run during this tick and will now run the next tick.</p>","location":"api/process/#returns_1"},{"title":"<code>suspend(ticks: number): void</code>","text":"<p>Prevent any listeners on this <code>Process</code> from being called for the next <code>ticks</code> simulation steps.</p>","location":"api/process/#markdown"},{"title":"Parameters","text":"<code>ticks: number = 1</code>  <p>The amount of simulation steps to pause for.</p>","location":"api/process/#parameters"},{"title":"Returns","text":"<p><code>void</code></p>  <p>Client/Server Parity Issue</p> <p>On the <code>Client</code>, <code>Process</code>es will always run at 60 Ticks per Second.</p> <p>On the <code>Server</code>, <code>Process</code>es will always run at whatever tick-rate you selected in your Manifest</p>    <p>Examples</p> Process CreationProcess Usage   <pre><code>import Tina from '@rbxts/tina';\n\nlet GameplayLoop = Tina.process(\"gameloop\"); // (1)!\n\n// If we ever forget or lose the process, we can always just fetch it;\n\nGameplayLoop = Tina.process(\"gameloop\"); // (2)!\n</code></pre> <ol> <li> Here we create a new process called <code>gameloop</code>.</li> <li> This will get us the exact same process, <code>gameloop</code>.</li> </ol>   <pre><code>import Tina from `@rbxts/tina`;\n\nGameplayLoop\n    .when()\n    .do((dt: number /* (1)!  */) =&gt; {\n        console.log(\"Hey!\");\n    });\n</code></pre> <ol> <li> <p> <code>dt</code> is always equal to the delta between the last time a tick was processed and the current time.</p> <p>This will not respect the latest run of the current process, it will respect the latest run of the overall process scheduler.</p> </li> </ol>","location":"api/process/#returns_2"},{"title":"Tina","text":"","location":"api/tina/"},{"title":"Tina","text":"","location":"api/tina/#tina"},{"title":"<code>registerGame(name: string, manifest: Manifest): void</code>","text":"<p>This initializes and registers your game.</p>","location":"api/tina/#markdown"},{"title":"Parameters","text":"<code>name: string</code>  <p>Usually the name of whatever game you're making; if you haven't got one yet, just mash your keyboard! This can always be changed in the future.</p>  <code>manifest: Manifest</code>   <p>A <code>Manifest</code> is a file that specifies some important information about your project</p>","location":"api/tina/#parameters"},{"title":"Returns","text":"<p><code>void</code></p>  <p>Order of Initialization</p> <p>It is important that functions like <code>Tina.setUserClass()</code> are called before <code>Tina.startGame()</code>.</p> <p>Please also consider that processes will only start running once you've called <code>Tina.startGame()</code>.</p>   <p>Well Done!</p> <p>Congrats on starting your latest project, we're glad to see you using Tina and we wish you all the best! </p>","location":"api/tina/#returns"},{"title":"<code>setUserClass(userClass: new (ref: Player | number) =&gt; User): void</code>","text":"","location":"api/tina/#markdown"},{"title":"Parameters","text":"<code>userClass: new (ref: Player | number) =&gt; User</code>  <p>The <code>userClass</code> needs to be the constructor (raw class) of your custom <code>User</code> class, instructions on how to implement a custom <code>User</code> can be viewed here.</p>","location":"api/tina/#parameters_1"},{"title":"Returns","text":"<p><code>void</code></p>","location":"api/tina/#returns_1"},{"title":"<code>process(name: string): Process</code>","text":"<p>Create a <code>Process</code>, this is the main utility for your so-called \"Game Loop\".</p>","location":"api/tina/#markdown"},{"title":"Parameters","text":"<code>name: string</code>  <p>The name of your process, make this short but memorable.</p>","location":"api/tina/#parameters_2"},{"title":"Returns","text":"<code>Process</code>   <p>If a <code>Process</code> with this <code>name</code> already exists, you'll be given that one, otherwise a new one will be created.</p>","location":"api/tina/#returns_2"},{"title":"Manifest","text":"","location":"api/types/manifest/"},{"title":"Manifest","text":"<p>The Manifest is a file you need to have in your workspace whenever working with Tina. This file should always be in the root of your project.</p> manifest.tina.yml<pre><code>name: \"Hello World\" # (1)!\nversion: \"0.0.1\" # (2)!\ndescription: \"My First Ever Project!\" # (3)!\nconfig:\n    tickrate: 20 # (6)!\n    net:\n        compression: true # (4)!\n    supported_languages: # (5)!\n        - fr-fr # French\n        - cs-cz # Czech\n        - en-us # English\n    max_players: 10 # (7)!\ntina: \"dev\" # IMPORTANT (8)\n</code></pre> <ol> <li>The name of your project, this can always be changed!</li> <li>The version of your project, we highly recommend that you use a versioning standard such as SemVer.</li> <li>Have some fun, this field isn't really necessary, but it's nice to write an elevator pitch for a game before you've even begun writing it!</li> <li>Whether or not to use compressed networking.</li> <li>All officially supported languages. You can find language codes here.</li> <li>The amount of times Server-Side Processes will run every second. We recommend using 20, 30, or 60, this is capped at 60.</li> <li>The maximum amount of players a single game server will accept; if another tries to join over the cap, they will be kicked and their data will never load.</li> <li> <p>IMPORTANT The current deployment environment.</p>    Value Description     <code>\"dev\"</code> Active development, this will leave any <code>.developmentOnly</code> endpoints on and will allow native console access.   <code>\"stable\"</code> The game is currently published, all <code>.developmentOnly</code> endpoints are off and native console access is no longer allowed.    </li> </ol>","location":"api/types/manifest/#manifest"},{"title":"Main Features","text":"<p>Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit.</p> <ol> <li> I'm an annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be expressed in Markdown.</li> </ol>","location":"intro/tina/core/"},{"title":"Main Usage","text":"","location":"intro/tina/core/#main-usage"},{"title":"Game","text":"<p>Tina requires certain initialization on the Server and the Client.</p> index.server.ts<pre><code>import Tina from '@rbxts/tina';\n\nimport 'lib/game'; // Initialize Game.\nimport 'lib/net'; // Initalize Networking.\nimport 'lib/ecs'; // Initalize Entity Component System.\n\nimport { User } from 'shared/lib/game/user';\n\n/* Starts the Game Processes */\nTina.setUserClass(User); // Sets the custom user class.\nTina.startGame(\"GuessTheNumber\"); // (1)!\n</code></pre> <ol> <li>This initializes the game and starts all processes. Tina.startGame</li> </ol> <p><code>index.client.ts</code></p> index.client.ts<pre><code>import Tina from '@rbxts/tina';\n\nimport 'lib/game'; // Initialize Game.\nimport 'lib/net'; // Initialize Networking.\nimport 'lib/ecs'; // Initialize Entity Component System.\n\nimport { User } from 'shared/lib/game/user';\n\n// TODO: Decide what client-side initialization needs to look like.\n</code></pre>","location":"intro/tina/core/#game"},{"title":"Events","text":"<pre><code>\n</code></pre>","location":"intro/tina/core/#events"},{"title":"Using the ECS","text":"<p>The ECS (Entity Component System) is a core feature of Tina.</p>","location":"intro/tina/ecs/"},{"title":"Tina's Purpose","text":"","location":"intro/tina/philosophy/"},{"title":"Ideology","text":"<p>Our ideology in creating Tina (\"Tina is not Aero\") was to create an optimized server-side solution for the problems many of our game ideas would've been faced with had we kept Roblox's backend philosophy.</p> <p>Tina aims to replace many of the traditional frameworks like AeroGameFramework, Knit, and Flamework; all of these rely heavily on Services/Controllers. Instead, Tina relies on various patterns such as heavily Event/Process-Driven Systems, where everything happens either because we're at the correct point in a \"Process\" or because a certain \"Event\" has flared. </p> <p>The primary method of interacting with the game world is with a flavoured Entity Component System; the Server only runs processing on any \"Components\" using \"Systems\", whilst the Client uses those Components along with \"Effects\" to run pre-rendering tasks or display any relevant information to the end-user.</p>","location":"intro/tina/philosophy/#ideology"},{"title":"Aether's Investment","text":"<p>We at Aether have always wanted to build ideas beyond the typical technical scope of Roblox projects, here we found ourselves at an impasse where the engine simply wasn't powerful enough to support enough characters, a large enough scale, provide proper - compressed data-based networking.</p> <p>Thus, we're spending a while working on Tina to facilitate our in-house projects and any other dreams people might have.</p>","location":"intro/tina/philosophy/#aethers-investment"},{"title":"Creating an Experience with Tina","text":"","location":"intro/tina/start/"},{"title":"Commands","text":"<ul> <li><code>rbxtsc -w</code> - Start the TypeScript compiler.</li> <li><code>rojo start</code> - Start the Rojo server.</li> </ul>","location":"intro/tina/start/#commands"},{"title":"Project layout","text":"<pre><code>default.project.json   # Rojo configuration\npackage.json\ntsconfig.json          # rbxts configuration\ntina.yml               # Tina configuration\n/node_modules/\n    # ...\n/src/\n    /client/\n        index.client.ts # Initalize the Client-Side, mostly through Tina\n        /lib/\n            /game/\n                index.ts # Start all core game loops/listeners.\n                # ... Large logic/core loops\n            /net/\n                index.ts\n                # ... Any special network handlers\n            /ecs/\n                /effects/\n                    # ... Any Effects used for entities\n                /systems/\n                    # ... Any Systems that interact with components/effects\n    /server/\n        index.server.ts\n        /lib/\n            /game/\n                index.ts # Start all core game loops/listeners.\n                # ... Large logic/core loops\n            /net/\n                index.ts\n                # ... Any special network handlers\n            /ecs/\n                /systems/\n                    # ... Any Systems that interact with components/effects\n    /shared/\n        index.ts\n        /lib/\n            /game/\n            /net/\n                index.ts # Exports the network definitions.\n                packets.d.ts # Provides all packet types for the network.\n            /ecs/\n                index.ts\n                /components/\n                    # ... All available components\n                /effects/\n                    # ... All available effects, without implementation.\n</code></pre>","location":"intro/tina/start/#project-layout"},{"title":"Conditions","text":"<p>Conditions are the way to perform and evaluate boolean operations whether they are wrapped around a <code>.condition()</code> or in an if-statement.</p>","location":"intro/tina/libraries/conditions/"},{"title":"Creating conditions","text":"<p>Conditions can be created as in <code>COND.create(f: (...args) =&gt; boolean)</code>. The function can take optional arguments when being evaluated.</p> <pre><code>COND.create((n: number) =&gt; (n &lt; 5))\n</code></pre>","location":"intro/tina/libraries/conditions/#creating-conditions"},{"title":"Evaluating conditions","text":"<p>Conditions by themselves aren't a big thing, they need some way to be evaluated. To evaluate conditions we use <code>.eval(condition: (boolean | (...args) =&gt; boolean))</code>.</p> <pre><code>/**\n * These are all valid ways to evaluate boolean operations.\n */\n\nCOND.eval(true);\nCOND.eval(COND.AND(false, true));\n\nCOND.eval(COND.create(() =&gt; true));\nCOND.eval(COND.create((s) =&gt; (s === \"Hello, world!\")), \"Hello, world!\");\n\nCOND.eval((n: number) =&gt; (n &gt; 0), 0);\n\nCOND.eval(GameState.isOn(...));\nCOND.eval(CharacterController.isReplicable(), new CharacterDescription(...));\n</code></pre>","location":"intro/tina/libraries/conditions/#evaluating-conditions"},{"title":"Conditions &amp; Events","text":"<p>Conditions true power starts to reveal for themselves when we use Events and their <code>.condition()</code> method, it's easier to wrap it around this statement to ensure that next-in-queue callback runs. This lets us have conditioning done in one place without polluting core functionality with unnecessary if-statements.</p> <pre><code>interface RoundEvents {\n    startRound: (timer: number) =&gt; void;\n}\n\nclass RoundService extends EventEmitter&lt;RoundEvents&gt; {\n    private readonly duration = 180;\n\n    constructor() {\n        super();\n\n        this.when(\"startRound\")\n            .condition(\n                COND.create((currentTime: number) =&gt; {\n                    return currentTime &gt;= this.duration;\n                })\n            )\n            .do(() =&gt; {\n                // If this code is executed, that means that the last condition check has passed,\n                // that way, this code ensures that the timer is correct.\n\n                ...; // Finish round, initialize next\n            });\n    }\n}\n</code></pre> <p>Though this can be used with outer state or boolean checkers made by the user.</p> <pre><code>import { GameState, EGameState } from \"../state\";\n\ninterface Events {\n approve: () =&gt; void;\n}\n\nclass Meal extends EventEmitter&lt;Events&gt; implements MealDeclaration {\n    private readonly \n\n    constructor() {\n        super()\n\n        this.when(\"approve\")\n            .condition(GameState.isOn(EGameState.ROUND_ON_GOING))\n            .do(() =&gt; {\n                ...; // Approve it if the round is still going\n            });\n    }\n\n    public prepare() { ... }\n}\n</code></pre>","location":"intro/tina/libraries/conditions/#conditions-events"},{"title":"Methods available","text":"<p>Conditions are not only helpful in evaluating boolean operations, but it provides you an API for those common boolean operations that you may find yourself doing over and over again, such as <code>AND</code>, <code>OR</code>, and <code>NOT</code>, but others like <code>NAND</code>, <code>NOR</code>, <code>XNOR</code> are included as well.</p>","location":"intro/tina/libraries/conditions/#methods-available"},{"title":"create","text":"<p>Takes a function that returns a boolean.</p> <pre><code>COND.create(() =&gt; true);\n</code></pre>","location":"intro/tina/libraries/conditions/#create"},{"title":"eval","text":"<p>Evaluates a condition. Data can be passed optionally if it's a function.</p> <pre><code>COND.eval((s: string) =&gt; (s === \"condition_met\"), \"condition_met\");\n</code></pre>","location":"intro/tina/libraries/conditions/#eval"},{"title":"AND","text":"<p>AND logic-gate.</p> <pre><code>COND.eval(COND.AND(true, false)); // false\n</code></pre>","location":"intro/tina/libraries/conditions/#and"},{"title":"OR","text":"<p>OR logic-gate.</p> <pre><code>COND.eval(COND.OR(true, false)); // true\n</code></pre>","location":"intro/tina/libraries/conditions/#or"},{"title":"NOT","text":"<p>NOT logic-gate.</p> <pre><code>COND.eval(COND.NOT(false)); // true\n</code></pre>","location":"intro/tina/libraries/conditions/#not"},{"title":"NOR","text":"<p>NOR logic-gate.</p> <pre><code>COND.eval(COND.NOR(true, false)); // false\n</code></pre>","location":"intro/tina/libraries/conditions/#nor"},{"title":"NAND","text":"<p>NAND logic-gate.</p> <pre><code>COND.eval(COND.NAND(false, false)); // true\n</code></pre>","location":"intro/tina/libraries/conditions/#nand"},{"title":"XNOR","text":"<p>XNOR logic-gate.</p> <pre><code>COND.eval(COND.XNOR(true, true)); // true\n</code></pre>","location":"intro/tina/libraries/conditions/#xnor"},{"title":"Events","text":"<p>Events are a core library that is used all over Tina, incluiding Networking. Events are useful when it comes to binding callbacks to a unique identifier and emitting data to it.</p> <pre><code>EventEmitter&lt;EventsInterface&gt;.when(x: keyof EventsInterface); // Returns an Event listener\n</code></pre> <p>Using the <code>.when(...)</code> method is necessary, since it returns an Event listener where the functions are binded and invoked from. Something you might find interesting is creating multiple chains of actions to be performed asynchronously. </p>","location":"intro/tina/libraries/events/"},{"title":"Conditions","text":"<p>Conditions are available to be done within events, that way you condition (pun intended) the next-in-queue callback. This is done using the <code>.condition()</code> method. You can see an implementation on Conditions with this method.</p> <p>The main idea behind the Conditions implementation within Events is that, the data sent to the Event is also used in the condition as well.</p>","location":"intro/tina/libraries/events/#conditions"},{"title":"Do","text":"<p>The \"do's\" are the way to bind functions as actions to be performed. The dos are the ones who are actually ran when the event is emitted.</p> <pre><code>interface Events {\n    onEvent: (message: string) =&gt; string;\n}\n\nconst Event = new EventEmitter&lt;Events&gt;\n    .when(\"onEvent\")\n    .do((message: string) =&gt; {\n        return `${message}, world!`\n    })\n    .do((concatenated: string) =&gt; print(concatenated));\n\nEvent.emit(\"onEvent\", \"Hello\");\n</code></pre>","location":"intro/tina/libraries/events/#do"},{"title":"Await","text":"<p>Events are asynchronous to their thread, this means that will run at the same time as your other code. Sometimes we want to await on some events until they are finished to proceed, even though, this isn't intended (as the do's chain solves that problem). We give you the opportunity to await on events until the final result is given.</p> <pre><code>// File 2\ninterface Events {\n    onThis: (message: string) =&gt; string;\n}\n\nexport const Event = new EventEmitter&lt;Events&gt;;\n\nEvent\n    .when(\"onThis\")\n    .do((message: string) =&gt; {\n        return `${message}, world!`\n    })\n    .do((message: string) =&gt; {\n        return `${message} Wow, this is amazing, a new world!`\n    })\n    .do((message: string) =&gt; {\n        return `${message} I don't feel like there's much to explore.`\n    })\n    .do((message: string) =&gt; {\n        return `${message} Well, I guess this is it.`\n    })\n    .await();\n\nprint(\"Hello, world\");\n\n// File 2\nimport { Event } from \"...\";\n\nEvent.emit(\"Hello\");\n\n/**\n * Hello, world!\n * Hello, world! Wow this is amazing, a new world!\n * Hello, world! Wow this is amazing, a new world! I don't feel like there's much to explore.\n * Hello, world! Wow this is amazing, a new world! I don't feel like there's much to explore. Well, I guess this is it.\n * \n * Hello, world!\n */\n</code></pre>","location":"intro/tina/libraries/events/#await"},{"title":"Processes","text":"<p>Processes are used to define logic which runs on every tick.</p>","location":"intro/tina/libraries/processes/"},{"title":"Creation","text":"<p>Processes should only be created by calling Tina.process() to guarantee there will only ever be one Process assigned to each unique string.</p> <pre><code>const GameProcess = Tina.process(\"main\")\n</code></pre>","location":"intro/tina/libraries/processes/#creation"},{"title":"Use","text":"<p>After a Process has been created, callbacks can be added to the Process using .do(). You can add as many callbacks as you want to each Process, and they will be executed in the order that they're added.</p> <pre><code>GameProcess.do(() =&gt; {\n    doSomething()\n})\n\nGameProcess.do(() =&gt; {\n    doSomethingElse()\n})\n</code></pre> <p>At this point all that's left is to start your Process by calling .resume(). Resuming a Process adds it to the Scheduler to be updated every tick and also un-suspends the Process if it was previously suspended with .suspend().</p> <pre><code>// doSomething() and doSomethingElse() will now be called on every tick\nGameProcess.resume()\n</code></pre>","location":"intro/tina/libraries/processes/#use"},{"title":"Suspension","text":"<p>Suspending Processes is a way to temporarily disable them for a set amount of time in ticks. After the duration passes, the suspension is removed and the Process will automatically resume running callbacks on each tick.</p> <pre><code>GameProcess.suspend(60) // Suspends the Process for 60 ticks\n</code></pre>","location":"intro/tina/libraries/processes/#suspension"},{"title":"Example","text":"<pre><code>/* Create new process */\nconst GameProcess = Tina.process(\"main\")\n\n/* Add a callback to run on each tick */\nGameProcess.do(() =&gt; {\n    // Do something\n    doSomething()\n\n    // Suspend the Process for 1 tick after this callback runs\n    // This is effectively calling this function every other tick\n    GameProcess.suspend(1)\n})\n\n/* Adds the Process to the Scheduler to update on each tick */\nGameProcess.resume()\n</code></pre>","location":"intro/tina/libraries/processes/#example"},{"title":"Networking","text":"<p>Tina provides a networking interface so you don't need to get it from somewhere else, the interface it's pretty intuitive and it's considered to be something similar to what HTTP Requests look like with methods such as <code>GET</code>, <code>POST</code>, and <code>UPDATE</code>. </p> <p>Your Endpoints (that's what they're called like) should be defined once and in a single file (recommended to be under <code>src/shared</code> folder). </p>","location":"intro/tina/libraries/net/net/"},{"title":"Repositories","text":"<p>Repositories are holders for Endpoints and other repositories, these repositories can have a scope, either being <code>development</code> or <code>production</code> (covered on \"Tina's yaml configuration\"). </p> <pre><code>Network.repository({ ...endpoints });\nNetwork.repository({ ...endpoints }).developmentOnly(); // Limited to the development enviroment\n</code></pre>","location":"intro/tina/libraries/net/net/#repositories"},{"title":"Endpoints","text":"<p>Endpoints are, as the name says, end points on your networking. These endpoints can be retrieved, send or receive information from either context. Endpoints are the core to the networking.</p>","location":"intro/tina/libraries/net/net/#endpoints"},{"title":"Register endpoints","text":"<p>To start working with the Networking, you should be registering it once and recommended to be in a single file.</p> <pre><code>// src/shared/net.ts\nexport const Endpoints = Network.registerEndpoints({\n    furniture: Network.repository({\n        checkId: Network.Method.GET&lt;string, boolean&gt;()\n    }),\n});\n</code></pre>","location":"intro/tina/libraries/net/net/#register-endpoints"},{"title":"GET Endpoint","text":"<p>GET is a way to communicate between both contexts, being able to receive data, and return back data depending on that data received earlier. GET only can be retrieved from the client, so the server AND ONLY the server can reply to these requests.</p> <p>The way to declare a GET Endpoint is to use the <code>Method</code> namespace inside <code>Tina</code> and pass the types to the generic functions as it follows.</p> <pre><code>Network.Method.GET&lt;sendType: string, returnType: number&gt;();\n</code></pre> <p>The <code>sendType</code> it's optional, and can be undefined, or just be skipped completely when using <code>.get()</code> instead of <code>.send()</code>.</p> <p>To connect and listen to clients requests, you use <code>.reply(callback: Callback)</code>.</p> <pre><code>&lt;string, boolean&gt;GETEndpoint.reply((id: string) =&gt; Conditions.eval(Registry.has(id)));\n</code></pre> <p>To get the data back from the request, you will need to make the request itself. This is made with 2 methods.</p> <pre><code>GETEndpoint.get(); // NO data being sent, so it doesn't take anything.\nGETEndpoint.send(...); // Data can be sent to the server.\n</code></pre> <p>Both ways will send the request and so on, expect for the reply.</p> <pre><code>GETEndpoint\n    .when()\n    .condition(Conditions.create((hasId: boolean) =&gt; hasId))\n    .do(() =&gt; {\n        ...; // perform client furniture placement\n    });\n\nGETEndpoint.send(\"{2345-23142-BED}\");\n</code></pre>","location":"intro/tina/libraries/net/net/#get-endpoint"},{"title":"UPDATE Endpoint","text":"<p>UPDATE is a way to communicate to the client and perform, as the name says, updates to it. </p> <p>The way to declare an UPDATE Endpoint is to use the <code>Method</code> namespace inside <code>Tina</code> and pass the type to send to the client as it follows.</p> <pre><code>Network.Method.UPDATE&lt;string&gt;();\n</code></pre> <p>The client is the only one that can connect to this Endpoint, and so the server it's only available to send data to it.</p> <pre><code>// Client\nUPDATEEndpoint\n    .when()\n    .condition(Conditions.create((message: string) =&gt; message === \"Hello!\"))\n    .do(() =&gt; {\n        ...; // code is right, perform client operation\n    });\n\n// Server\nUPDATEEndpoint.send(\"Hello!\");\n</code></pre>","location":"intro/tina/libraries/net/net/#update-endpoint"},{"title":"POST Endpoint","text":"<p>POST is a way to send data to the server. Either to work with it, or to verify it (though verifications are highly discouraged to use POST, instead, use GET).</p> <p>The way to declare an UPDATE Endpoint is to use the <code>Method</code> namespace inside <code>Tina</code> and pass the type to send to the client as it follows.</p> <pre><code>Network.Method.POST&lt;{ data: { kills: number } }&gt;();\n</code></pre> <p>The server is the only one that can connect to this Endpoint, and so the client it's only available to send data to it.</p> <pre><code>// Server\nPOSTEndpoint\n    .when()\n    .condition(Conditions.create(({ data }: ...) =&gt; Register.checkDeath(data.kills)));\n    .do(() =&gt; {\n        ...; // all right, perform anything needed\n    });\n\n// Client\nPOSTEndpoint.send({\n    data: {\n        kills: 0,\n    },\n})\n</code></pre>","location":"intro/tina/libraries/net/net/#post-endpoint"},{"title":"Middleware","text":"<p>Coming soon.</p>","location":"intro/tina/libraries/net/net/#middleware"}]}