---
icon: material/cube
---

# :material-package-variant-closed: ECS

## :material-cube: Component

<!-- todo: ComponentTypes -->

### :material-function-variant: **`#!typescript createComponent<T extends Tree<Type>>(schema: T): Component<T>`** { #markdown data-toc-label='createComponent' }

Creates a component that matches the given schema.

Internally this creates an array for each property in the schema, where the index of the array matches an entity id. This allows for fast lookups of component data.

The array is pre-allocated to the given size, so it is important to ensure that you do not access the component data for an entity that does not exist, or that does not have the component. This is because the array could hold data for a given entity, even though the entity would be invalid. You can use [`#!typescript world.hasComponent()`](../api/entityid.md/#markdown "EntityId.isValid()") to ensure that the entity has the given component before accessing the component data if required.

Components are singletons and should be created once per component type. Components also persist between worlds, therefore you do not need more than one component per world. EntityIds are global, therefore the index of a given entity will always match the index of the component data.

#### Parameters
`#!typescript schema: Tree<Type>`

 : The schema of the component. This can match any type, but it is recommended to use [`#!typescript ComponentTypes`](../api/tree.md/#markdown "ComponentTypes") to ensure that the component is automatically serializable.

#### Returns

`#!typescript Component<T>`

 : The [`#!typescript Component`](../api/component.md/#markdown "Component") that was created.

### :material-function-variant: **`#!typescript createTag(): TagComponent`** { #markdown data-toc-label='tagComponent' }

Creates a tag component; a component that has no data.

Tags are useful for marking entities as having a certain property, without the overhead **of** storing any data. For example, you could use a tag component to mark an entity as being a player, and then use a system to query for all entities that have the player tag.

Tags are singletons and should be created once per component type. Tags also persist between worlds, therefore you do not need more than one Tag per world.


## :material-cube: System

#### System Parameters

`#!typescript after?: Array<System>`

 : An optional set of systems must be executed before this system. This is useful for ensuring that a system is executed after another system (e.g. when a system relies on the data generated by another system).

`#!typescript dt?: number`

 : The delta time, in seconds, since the last call of this system. This is useful for systems that need to update based on time, such as physics systems.

`#!typescript enabled?: boolean`

 : Whether or not a system should be called. This should not be called directly. Instead, you should use the [`#!typescript world.enableSystem()`](../api/world.md/#markdown "World.enableSystem()") and [`#!typescript world.disableSystem()`](../api/world.md/#markdown "World.disableSystem()") functions respectively.

`#!typescript executionGroup?: ExecutionGroup`

 : The group that this system will be executed on, e.g. PostSimulation, PreAnimation, etc. The only requirement for an execution group is that the group has a `Connect` method.

`#!typescript name?: string`

 : The name of the system. This is primarily used for debugging purposes.

`#!typescript priority?: number`

 : The priority of the system. Systems with a higher priority will be executed before systems with a lower priority. This number defaults to `0`, and therefore can be either positive or negative.

### :material-function-variant: **`#!typescript public abstract onUpdate(world: World): void`** { #markdown data-toc-label='onUpdate' }

The onUpdate method is called on every execution of this systems execution group. This should not typically be called manually, and instead, the system should be scheduled according to an execution group using the [`#!typescript world.scheduleSystem()`](../api/world.md/#markdown "World.scheduleSystem()") function.

#### Parameters
`#!typescript world: World`

 : The world that this system is being executed on. This will be automatically passed in by the owning world on each system execution.

### :material-function-variant: **`#!typescript public configureQueries(world: World): void`** { #markdown data-toc-label='configureQueries' }

The configureQueries method is optionally called when the system is first run. This is typically used to configure the queries that the system will use, however, it can also be used to perform any other setup logic as required.

#### Parameters
`#!typescript world: World`

 : The world that this system is being executed on. This will be automatically passed in by the owning world.



## :material-cube: World

The world is the main access point for ECS functionality. It is responsible for creating and managing entities, components, and systems.

Typically there is only a single world, but there is no limit on the number of worlds an experience can create.

#### Usage

```typescript
import { World } from "@rbxts/tina";

const world = new World({...});
```

#### Parameters

`#!typescript id?: string`

 : A unique identifier for the world.

`#!typescript readonly options?: WorldOptions`

 : The [WorldOptions](../api/worldoptions.md/#markdown "WorldOptions") that were passed into the constructor when the world was created.


### :material-function-variant: **`#!typescript public add(): EntityId`** { #markdown data-toc-label='add' }

Creates a new entity in the world.

When the entity is added to the world, the id will be assigned immediately, but as all other operations are deferred, the entity will not be added to any queries until the system has finished executing.

#### Returns

`#!typescript EntityId`

 : The id of the newly created entity.


### :material-function-variant: **`#!typescript public addComponent<T extends Tree<Type>>(entityId: EntityId, component: Component<T>): this`** { #markdown data-toc-label='addComponent' }

Adds a given component to the entity. If the entity does not exist, then an error will be thrown. No error will be thrown if the entity already has the component.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to add the component.

`#!typescript component: Component<T>`

 : The component to add to the entity, which must have been defined previously with [`#!typescript createComponent()`](../api/component.md/#markdown "createComponent()").

`#!typescript data?: Partial<OptionalKeys<GetComponentSchema<C>>`

 : The optional data to initialize the component with. This must match keys of the original component schema.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public addTag(entityId: EntityId, tag: TagComponent): this`** { #markdown data-toc-label='addTag' }

Adds a tag component to an entity.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to add the tag.

`#!typescript tag: TagComponent`

 : The tag component to add to the entity, which must have been defined previously with [`#!typescript createTag()`](../api/component.md/#markdown "createTag()").

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public clear(): void`** { #markdown data-toc-label='clear' }

Removes all entities from the world.

!!! warning "This is currently not implemented and will throw an error if called."


### :material-function-variant: **`#!typescript public createQuery(...raw: Array<RawQuery>): Query`** { #markdown data-toc-label='createQuery' }

Creates a new query to filter entities based on the given components.

#### Usage Example:

```typescript
import { ALL, ANY, NOT } from "@rbxts/tina";
import { Position, Velocity, Acceleration } from "./components";

const query = world.createQuery(Position, ANY(Velocity, NOT(Acceleration)));
```

#### Parameters
`#!typescript ...raw: Array<RawQuery>`

 : A query using components, and optionally the provided query helper functions [`#!typescript ALL()`](../api/query.md/#markdown "ALL()"), [`#!typescript ANY()`](../api/query.md/#markdown "ANY()"), and [`#!typescript NOT()`](../api/query.md/#markdown "NOT()").

#### Returns

`#!typescript Query`

 : A new [Query](../api/query.md/#markdown "Query").

### :material-function-variant: **`#!typescript public destroy(): void`** { #markdown data-toc-label='destroy' }

Halts the current execution of the world, and destroys the world.

!!! warning "Depending on the number of entities a world has, this can be a costly operation as we have to return all the entities to the pool."

### :material-function-variant: **`#!typescript public disableSystem(): this`** { #markdown data-toc-label='disableSystem' }

Disables the given system. This will prevent the system from being executed, but will not remove it from the scheduler.

As scheduling a system can be a potentially expensive operation, this should be used for systems that are expected to be re-enabled in the future.

#### Parameters
`#!typescript system: System`

 : The system to disable.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.

### :material-function-variant: **`#!typescript public enableSystem(): this`** { #markdown data-toc-label='enableSystem' }

Enables the given system.

This will not error if a system that is already enabled is enabled again.

#### Parameters
`#!typescript system: System`

 : The system that should be enabled.

#### Returns
    
`#!typescript this`
    
: The world instance to allow for method chaining.

### :material-function-variant: **`#!typescript public flush(): void`** { #markdown data-toc-label='flush' }

Flushes any pending entity removal, or deferred component changes in the world.

This is called automatically whenever a system has finished executing, and should not typically be called manually.

If you are not using the inbuilt scheduler, you should call this method at regular intervals to ensure that any pending changes are applied.

### :material-function-variant: **`#!typescript public has(entityId: EntityId): boolean`** { #markdown data-toc-label='has' }

Checks if a given entity is currently alive in the world.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to check.

#### Returns

`#!typescript boolean`

 : True if the entity is alive, false otherwise.


### :material-function-variant: **`#!typescript public hasAllOf(entityId: EntityId, ...components: Array<AnyComponent>): boolean`** { #markdown data-toc-label='hasAllOf' }

Checks if a given entity has all of the given components.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to check.

`#!typescript ...components: Array<AnyComponent>`

 : Any number of components to check against.


#### Returns

`#!typescript boolean`

 : True if the entity has all of the given components, false otherwise.


### :material-function-variant: **`#!typescript public hasAnyOf(entityId: EntityId, ...components: Array<AnyComponent>): boolean`** { #markdown data-toc-label='hasAnyOf' }

Checks if a given entity has any of the given components.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to check.

`#!typescript ...components: Array<AnyComponent>`

 : Any number of components to check against.


#### Returns

`#!typescript boolean`

 : True if the entity has at least one of the given components, false otherwise.


### :material-function-variant: **`#!typescript public hasComponent(entityId: EntityId, component: AnyComponent): boolean`** { #markdown data-toc-label='hasComponent' }

Returns whether or not the given entity has the given component.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to check.

`#!typescript component: AnyComponent`

 : Any number of components to check against.

#### Returns

`#!typescript boolean`

 : True if the entity has the given component, false otherwise.


### :material-function-variant: **`#!typescript public hasNoneOf(entityId: EntityId, ...components: Array<AnyComponent>): boolean`** { #markdown data-toc-label='hasNoneOf' }

Checks if a given entity has none of the given components.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to check.

`#!typescript ...components: Array<AnyComponent>`

 : Any number of components to check against.


#### Returns
    
`#!typescript boolean`
    
 : True if the entity has none of the given components, false otherwise.


### :material-function-variant: **`#!typescript public hasTag(entityId: EntityId, tag: TagComponent): boolean`** { #markdown data-toc-label='hasTag' }

Returns whether or not the given entity has the given tag.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to check.

`#!typescript tag: TagComponent`

 : The tag to check against.

#### Returns

`#!typescript boolean`

 : True if the entity has the given tag, false otherwise.


### :material-function-variant: **`#!typescript public pause(): void`** { #markdown data-toc-label='pause' }

Pauses the execution of the world.

!!! warning "This is currently not implemented and will throw an error if called."


### :material-function-variant: **`#!typescript public play(): void`** { #markdown data-toc-label='play' }

Continues the execution of the world from its current state.

!!! warning "This is currently not implemented and will throw an error if called."


### :material-function-variant: **`#!typescript public remove(entityId: EntityId): this`** { #markdown data-toc-label='remove' }

Removes the given entity from the world, including all of its components.

The entity will be removed from the world upon the next call to [`#!typescript flush()`](../api/world.md/#markdown "flush()").

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to remove.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public removeComponent(entityId: EntityId, component: AnyComponent): this`** { #markdown data-toc-label='removeComponent' }

Removes the given component from the given entity.

The component will be removed from the entity upon the next call to [`#!typescript flush()`](../api/world.md/#markdown "flush()").

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to remove the component.

`#!typescript component: AnyComponent`

 : The component to remove.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public removeQuery(query: Query): this`** { #markdown data-toc-label='removeQuery' }

Removes a query from the world.

Queries typically do not need to be removed and should last the lifetime of the world. However, this method is provided for cases in which this statement proves false.

#### Parameters
`#!typescript query: Query`

 : The query to remove.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public removeTag(entityId: EntityId, tag: TagComponent): this`** { #markdown data-toc-label='removeTag' }

Removes the given tag from the given entity.

#### Parameters
`#!typescript entityId: EntityId`

 : The id of the entity to remove the tag.

`#!typescript tag: TagComponent`

 : The tag to remove.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public scheduleSystem(system: System): this`** { #markdown data-toc-label='scheduleSystem' }

Schedules an individual system to be executed in the world.

Calling this function is a potentially expensive operation and should be avoided if possible. It is best advised to use [`#!typescript scheduleSystems()`](../api/world.md/#markdown "scheduleSystems()") instead, and add multiple systems at once - this is to avoid the unnecessary overhead of sorting systems.

#### Parameters
`#!typescript system: System`

 : The system to schedule.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public scheduleSystems(...systems: Array<System>): this`** { #markdown data-toc-label='scheduleSystems' }

Schedules a given set of systems to be executed in the world.

#### Parameters
`#!typescript ...systems: Array<System>`

 : Any number of systems to schedule.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public size(): number`** { #markdown data-toc-label='size' }

#### Returns

`#!typescript number`

 : Returns the number of entities currently in the world.


### :material-function-variant: **`#!typescript public start(): this`** { #markdown data-toc-label='start' }

Starts the execution of the world.

This should only be called after all components, and preferably all systems have been registered.


### :material-function-variant: **`#!typescript public toString(): string`** { #markdown data-toc-label='toString' }

#### Returns

`#!typescript string`

 : The name of the world. This defaults to "World", unless specified by the WorldOptions.


### :material-function-variant: **`#!typescript public unscheduleSystem(system: System): this`** { #markdown data-toc-label='unscheduleSystem' }

Unschedule an individual system from the world.

If a system needs to be re-scheduled at a later time, then it is recommended instead to disable it using [`#!typescript disableSystem()`](../api/world.md/#markdown "disableSystem()"), as scheduling a system will require the systems to be sorted again.

#### Parameters
`#!typescript system: System`

 : The system to unschedule.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.


### :material-function-variant: **`#!typescript public unscheduleSystems(...systems: Array<System>): this`** { #markdown data-toc-label='unscheduleSystems' }

Unschedule a given set of systems from the world.

If a system needs to be re-scheduled at a later time, then it is recommended instead to disable it using [`#!typescript disableSystem()`](../api/world.md/#markdown "disableSystem()"), as scheduling a system will require the systems to be sorted again.


#### Parameters
`#!typescript ...systems: Array<System>`

 : Any number of systems to unschedule.

#### Returns

`#!typescript this`

 : The world instance to allow for method chaining.****


## :material-cube: Query

A query is used to filter entities from the world based on their components.

To create a query, use the [`#!typescript createQuery()`](../api/world.md/#markdown "createQuery()") method, which takes a set of components, and will return a query that matches all the entities in the owning world that have the given components.

Queries can be created using the helper functions [`#!typescript all()`](../api/query.md/#markdown "ALL()"), [`#!typescript any()`](../api/query.md/#markdown "ANY()"), and [`#!typescript none()`](../api/query.md/#markdown "NOT()"), which can be used to create complex queries.


#### Usage

```typescript
import { World, ALL, ANY, NOT } from '@rbxts/tina';
import { Position, Velocity, Acceleration } from './components';

const world = new World({...});
const query = world.createQuery(Position, ANY(Velocity, NOT(Acceleration)));
query.forEach(entityId => {
    // ...
});
```

!!! note "The order of iteration for a query is not guaranteed."


### :material-function-variant: **`#!typescript public match(target: Array<ComponentId>, mask: QueryMask): boolean`** { #markdown data-toc-label='match' }

Traverses the query mask, and returns true if the archetype mask matches the given query.

This function is not typically used directly but is used internally by the world to determine if an entity matches a query.

#### Parameters
`#!typescript target: Array<ComponentId>`

 : The archetype mask to match against.

`#!typescript mask: QueryMask`

 : The query mask to match against.

#### Returns

`#!typescript boolean`

 : True if the query mask matches the archetype mask.



### :material-function-variant: **`#!typescript public forEach(callback: (entityId: EntityId) => void): void`** { #markdown data-toc-label='forEach' }

Runs a callback for each entity that matches the query.

If the callback returns `false`, the iteration will stop, and no other entities in the query will be iterated over.

#### Usage:
```typescript
query.forEach(entityId => {
    // ...
});
```

#### Parameters
`#!typescript callback: (entityId: EntityId) => boolean | void`

 : The callback run for each entity in the query.


## Query Helper Functions

Below are a set of helper functions that can be used to create queries.

These functions are used in conjunction with the [`#!typescript createQuery()`](../api/world.md/#markdown "createQuery()") method, and should not be used directly.

### :material-function-variant: **`#!typescript ALL(...components: Array<RawQuery | AnyComponent>): RawQuery`** { #markdown data-toc-label='ALL' }

Matches to all provided components.

#### Usage:
```typescript
// An entity must have components A, B and C.
ALL(ComponentA, ComponentB, ComponentC)

// An entity must have component A, and either component B or C.
ALL(ComponentA, ANY(ComponentB, ComponentC))
```

#### Parameters
`#!typescript ...components: Array<RawQuery | AnyComponent>`

 : Any number of components to match against.


### :material-function-variant: **`#!typescript ANY(...components: Array<RawQuery | AnyComponent>): RawQuery`** { #markdown data-toc-label='ANY' }

Matches to any of the provided components.

#### Usage:
```typescript
// An entity must have either component A, B or C.
ANY(ComponentA, ComponentB, ComponentC)

// An entity must have either component A, or both component B and C.
ANY(ComponentA, ALL(ComponentB, ComponentC))
```

#### Parameters
`#!typescript ...components: Array<RawQuery | AnyComponent>`

 : Any number of components to match against.


### :material-function-variant: **`#!typescript NOT(...components: Array<RawQuery | AnyComponent>): RawQuery`** { #markdown data-toc-label='NOT' }

Matches to entities that do not have any of the provided components.

#### Usage:
```typescript
// An entity must not have component A, B or C.
NOT(ComponentA, ComponentB, ComponentC)

// An entity must not have component A, or both component B and C.
NOT(ComponentA, ALL(ComponentB, ComponentC))
```

#### Parameters
`#!typescript ...components: Array<RawQuery | AnyComponent>`

 : Any number of components to match against.


